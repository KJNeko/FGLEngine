//
// Created by kj16609 on 11/28/23.
//

#pragma once

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"
#pragma GCC diagnostic ignored "-Wduplicated-branches"
#include <glm/glm.hpp>
#pragma GCC diagnostic pop

#include <filesystem>
#include <memory>
#include <vector>

#include "Primitive.hpp"
#include "assets/material/Material.hpp"
#include "descriptors/Descriptor.hpp"
#include "descriptors/DescriptorSetLayout.hpp"
#include "memory/buffers/vector/IndexedVector.hpp"
#include "primitives/boxes/OrientedBoundingBox.hpp"
#include "rendering/PresentSwapChain.hpp"

namespace fgl::engine
{
	struct Primitive;
	struct ModelInstanceInfo;
	struct PrimitiveInstanceInfo;
	struct PrimitiveRenderInfo;
	struct ModelGPUBuffers;
	class ModelInstance;
	struct ModelResourceBuffers;
	struct ModelRenderInfo;
	class ModelRenderHandle;

	namespace memory
	{
		class Buffer;
	}

	struct ModelBuilder;

	ModelGPUBuffers& getModelBuffers();

	// Primitive render info, Contains the vertex and index info
	constexpr descriptors::Descriptor RENDER_INFO_DESCRIPTOR { 0,
		                                                       vk::DescriptorType::eStorageBuffer,
		                                                       vk::ShaderStageFlagBits::eCompute };

	inline static descriptors::DescriptorSetLayout PRIMITIVE_SET { 0, RENDER_INFO_DESCRIPTOR };

	// Contains the information for each primitive (material ID, ect)
	constexpr descriptors::Descriptor PRIMITIVE_INSTANCE_DESCRIPTOR { 0,
		                                                              vk::DescriptorType::eStorageBuffer,
		                                                              vk::ShaderStageFlagBits::eCompute };

	// contains the model information, Such as model matricies
	constexpr descriptors::Descriptor MODEL_INSTANCE_DESCRIPTOR { 1,
		                                                          vk::DescriptorType::eStorageBuffer,
		                                                          vk::ShaderStageFlagBits::eCompute };

	inline static descriptors::DescriptorSetLayout INSTANCES_SET { 1,
		                                                           PRIMITIVE_INSTANCE_DESCRIPTOR,
		                                                           MODEL_INSTANCE_DESCRIPTOR };

	constexpr descriptors::Descriptor COMMANDS_DESCRIPTOR { 0,
		                                                    vk::DescriptorType::eStorageBuffer,
		                                                    vk::ShaderStageFlagBits::eCompute };

	// Contains the per instance vertex info
	constexpr descriptors::Descriptor VERTEX_INSTANCE_INFO { 1,
		                                                     vk::DescriptorType::eStorageBuffer,
		                                                     vk::ShaderStageFlagBits::eCompute };

	inline static descriptors::DescriptorSetLayout COMMANDS_SET { 2, COMMANDS_DESCRIPTOR, VERTEX_INSTANCE_INFO };

	struct PerVertexInstanceInfo
	{
		alignas( 4 * 4 ) glm::mat4x4 m_model_matrix;
		MaterialID material_id;
	};

	static_assert( sizeof( glm::mat4x4 ) == 64 );
	static_assert( offsetof( PerVertexInstanceInfo, m_model_matrix ) == 0 );

	static_assert( offsetof( PerVertexInstanceInfo, material_id ) == 64 );
	static_assert( sizeof( MaterialID ) == 4 );

	static_assert( sizeof( PerVertexInstanceInfo ) == 64 + ( 4 * 4 ) );

	struct ModelGPUBuffers
	{
		// buffer for long-term data. Not commonly updated
		memory::Buffer m_long_buffer;
		// Buffer for commonly updated data
		memory::Buffer m_short_buffer;

		memory::Buffer m_vertex_buffer;
		memory::Buffer m_index_buffer;

		//! Generated by the compute shader, This vector contains the instance info for each primitive.
		PerFrameArray< DeviceVector< PerVertexInstanceInfo > > m_generated_instance_info;

		//! contains the core primitive info, like vertex and index offsets and counts
		IndexedVector< PrimitiveRenderInfo > m_primitive_info;
		//! contains a list of all rendered primitives
		IndexedVector< PrimitiveInstanceInfo > m_primitive_instances;
		//! Contains a list of all models
		IndexedVector< ModelInstanceInfo > m_model_instances;

		std::shared_ptr< descriptors::DescriptorSet > m_primitives_desc;
		std::shared_ptr< descriptors::DescriptorSet > m_instances_desc;

		ModelGPUBuffers();
	};

	class Model final : public AssetInterface< Model >, public std::enable_shared_from_this< Model >
	{
		// Fills the GPU indexed vector with the parameters required for rendering
		static OrientedBoundingBox< CoordinateSpace::Model >
			buildBoundingBox( const std::vector< Primitive >& primitives );

		std::string m_name { "Unnamed model" };

		std::vector< Primitive > m_primitives {};

	  public:

		Model( std::vector< Primitive >&& primitives, const std::string& name = {} );

		~Model() = default;

		[[nodiscard]] bool ready() const;

		//TODO: Switch to using shared_ptr instead of unique_ptr
		static std::shared_ptr< Model > createModel( const std::filesystem::path& path );

		static std::shared_ptr< Model >
			createModelFromVerts( std::vector< ModelVertex > verts, std::vector< std::uint32_t > indicies );

		const std::string& getName() const { return m_name; }

		std::shared_ptr< ModelInstance > createInstance();

		Model( const Model& model ) = delete;
		Model& operator=( const Model& other ) = delete;
		Model( Model&& other ) = delete;
	};

} // namespace fgl::engine